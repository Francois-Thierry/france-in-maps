<!doctype html>
<html lang="en"class="no-js">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title class="EN">France in maps</title>
  <title class="FR">La France en cartes</title>

  <link rel="stylesheet" href="../assets/main.css">

  <script src="../assets/external/jquery-3.1.0.min.js"></script>
  <script src="../assets/external/xlsx.full.min.js"></script>
  <script src="../assets/external/d3.v4.2.4.min.js"></script>
  <script src="../assets/external/topojson.v2.min.js"></script>

  <!-- Helpful ressources -->
  <!-- http://madewithenvy.com/ecosystem/articles/2015/local-maps-with-canvas-d3/ -->
  <!-- http://chimera.labs.oreilly.com/books/1230000000345/ch12.html -->
  <!-- https://jgaffuri.github.io/france2json/revenues_map.html -->


</head>
<body>

<div class="wrapper">
  <div class="header"></div>
  <div class="row">
  	<div class="column-12">
  		<h1 class="EN">France in maps</h1>
  		<h1 class="FR">La France en cartes</h1>
  		<p class="EN">
  			This webpage is a tryout.

  			I use shapefiles from <a href="https://www.data.gouv.fr/fr/datasets/fond-de-carte-des-codes-postaux/" target="_blank">data.gouv.fr</a>. I then convert the shapefiles using ogr2ogr from the <a href="http://www.gdal.org/" target="_blank">Geospatial Data Abstraction Library (GDAL)</a>.
  		</p>
  		<p class="FR">
  			Cette page est un test de cartographie des données de l'INSEE. Idéalement elle devrait permettre de produire le même type de carte que celles de l'excellent livre "Le mystère français" de Hervé Le Bras et Emmanuel Todd et ajouter de l'interactivité en choisissant parmi les données et les périodes disponibles.
  		</p>
  		<p class="FR">
  			J'utilise des fichiers formes provenant de <a href="https://www.data.gouv.fr/fr/datasets/decoupage-administratif-communal-francais-issu-d-openstreetmap/" target="_blank">data.gouv.fr</a> (version enrichie et simplifiée à 100m). J'ai ensuite convertit le fichier .shp en GeoJSON en utilisant ogr2ogr de la <a href="http://www.gdal.org/" target="_blank">librairie d'abstraction de données géospatiales (GDAL)</a>. 
  		</p>
  		<p class="code">
  			ogr2ogr -f GeoJSON -t_srs crs:84 geo.json communes-20150101-100m.shp</i>
  		</p>
  		<p class="FR">
  			Puis en TopoJSON pour réduire la taille du fichier (-60%!) et ainsi accélérer le chargement.
  		</p>
  		<p class="code">
  			geo2topo -o topo.json -q 1e6 geo.json
  		</p>
  		<p class="FR">
  			J'ai ensuite encore réduit la taille du fichier (-27%) en retirant les attributs dont je n'avais pas besoin. J'ai ainsi retiré les attributs x_chf_lieu, y_chf_lieu, wikipedia, statut, population, lat_centro et lon_centro à l'aide d'un script Python.
  		</p>
  		<p class="FR">
  			Grâce aux attributs (et à TopoJSON) on affiche différents niveaux de résolutions (communes - cantons - départements - régions) avec les mêmes données en fusionnant les géométries qui ont des attributs en commun.
  		</p>
  	</div>
    <div class="row plot column-12">
      <div class="column-12" style="display:inline-flex;" class="selector">
        <h3 id="code_regn" class="active">Régions (2015)</h2>
        <h3 id="code_reg">Régions</h2>
        <h3 id="code_dept">Départements</h2>
        <h3 id="code_cant">Cantons</h2>
        <h3 id="code_com">Communes</h2>
      </div>
      <div>
        <canvas id="map"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- ----------------------------------------------------------------------- -->
<!--                                                              Javascript -->
<!-- ----------------------------------------------------------------------- -->

<script src="../assets/main.js"></script>

<script type="text/javascript">

	var width = 860;
	var height = 640;
  var viewport = [0, 860, 0, 640];

  var elements = [];
  var zoomLevel = 0;
  var selectedElement = null;
	var selectedCode = "code_regn";

  var regn = {"32":"Hauts-de-France", "44":"Grand-Est", "28":"Normandie", "53":"Bretagne", "52":"Pays de la Loire", "24":"Centre Val de Loire", "11":"Ile-de-France", "27":"Bourgogne Franche-Comté", "75":"Nouvelle Aquitaine", "84":"Auvergne Rhônes-Alpes", "76":"Occitanie", "93":"Provence-Alpes-Côte d'Azur", "94":"Corse"}

  // // Use either Lambert Conformal Conic or Orthographic for Europe
  // // (http://www.georeference.org/doc/guide_to_selecting_map_projections.htm)
  // // see also http://kartoweb.itc.nl/geometrics/map%20projections/mappro.html and http://xkcd.com/977/
  var projection = d3.geoConicConformal()
    .scale(3600)
    .center([3.2, 46.4])
    .translate([width/2, height/2]);

  var canvas = d3.select('#map')
    .attr('width', width)
    .attr('height', height)
    .attr("id", "mapCanvas")

  var ctx = canvas.node().getContext("2d");
  ctx.lineWidth = "0.5";
  ctx.fillStyle = "white"
      
  var path = d3.geoPath()
    .projection(projection)
    .context(ctx)

  // var zoom = d3.behavior.zoom()
  //   .translate([0, 0])
  //   .scale(1)
  //   .scaleExtent([1, 8])
  //   .on("zoom", zoomed);

  var geographicCodes = ["code_com", "code_cant", "code_dept", "code_reg", "code_regn"];

  d3.json("topo.json", function(error, map) {
    if (error) throw error;

    // // (ACCESSORY) UPDATE PROPERTIES (SEE BOTTOM)
    // d3.text("table-appartenance-geo-communes-15.csv", function(data) {
    //   dataLinks = d3.csvParse(data);
    //   elements = extractElements(map, selectedCode);
    //   drawMap(elements);
    // });

    elements = extractElements(map, selectedCode);
    drawMap(elements);

    $(".row.plot h3").click(function(){
      $(".row.plot h3").removeClass("active");
      $(this).addClass("active");
      selectedCode = $(this).attr("id");
      elements = extractElements(map, selectedCode);
      drawMap(elements)
    })

    canvas.on("click", clicked);
    // canvas.on("click", makeDoubleClick(reset, clicked));

    function reset() {
      console.log("RESET")
    }

    function clicked() {
      if (zoomLevel == 0) {      
        var mousePos = d3.mouse(this);
        elements.forEach(function(element) {
          ctx.beginPath();
          path(element);
          ctx.closePath();
          if (ctx.isPointInPath(mousePos[0], mousePos[1]) == true) {
            var bounds = path.bounds(element);
            var dx = bounds[1][0] - bounds[0][0];
            var dy = bounds[1][1] - bounds[0][1];
            var x = (bounds[0][0] + bounds[1][0]) / 2;
            var y = (bounds[0][1] + bounds[1][1]) / 2;
            var scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height)));
            var translate = [width / 2 - scale * x, height / 2 - scale * y];
            ctx.save();
            ctx.translate(translate[0], translate[1]);
            ctx.scale(scale, scale);
            ctx.lineWidth = 0.5*1/scale;
            selectedElement = element;
            drawMap(elements);
            zoomLevel += 1;
            console.log(regn[element.properties.id]);
            console.log(JSON.stringify(bounds))
            viewport = [-translate[0]/scale, width/scale-translate[0]/scale, -translate[1]/scale, height/scale-translate[1]/scale]
            console.log(viewport)
          }
        })
      } else {
        ctx.restore();
        zoomLevel = 0;
        viewport = [0, 860, 0, 640];
        drawMap(elements);
      }
    }
    
    // var zoom = d3.zoom()
    //   .scaleExtent([2/3, 2])
    //   .on("zoom", zoomed);

    // canvas.call(zoom);

    // function zoomed() {
    //   ctx.lineWidth = 1.5 / d3.event.scale;
    //   ctx.translate(d3.event.transform.x, d3.event.transform.y);
    //   ctx.scale(d3.event.transform.k, d3.event.transform.k);
    //   drawMap(elements);
    // }

  });

  function extractElements(map) {
    console.time("extracting");
    // prepare elements
    var elements = [];
    // select dataset geometries
    var dataset = map.objects.geo.geometries;
    // sort the dataset by the geographic code
    dataset.sort(function(a, b) {return d3.ascending(a.properties[selectedCode], b.properties[selectedCode])})
    // initialize a group code
    var groupCode = ""
    // for every object in the map
    for (var i = 0; i < dataset.length; i++) {
      if (selectedCode == "code_com") {
        // use every object
        elements.push(topojson.feature(map, dataset[i]));
      } else {
        // get the corresponding geographic code
        var id = dataset[i].properties[selectedCode];
        // if it doesn't exist
        if (id != groupCode) {
          // if a group already exist
          if (group != undefined) {
            // merge the paths
            mergedPath = topojson.merge(map, group)
            mergedPath.properties = {"id":groupCode}
            // use the merged group
            elements.push(mergedPath)
          }
          // update the group code
          groupCode = id;
          // if it doesn't exist create it
          var group = [dataset[i]];
        } else {
          // add it to the group if it is the same code as the
          // previous one
          group.push(dataset[i])
        }
      }   
    }
    console.timeEnd("extracting");
    return elements;
  }

  function drawMap(elements) {
    console.time("drawing");
    // save current context with transform
    ctx.save();
    // Use the identity matrix while clearing the canvas
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    // clear the canvas
    ctx.clearRect(0, 0, width, height);
    // restore transforms on canvas
    ctx.restore();
    // draw every object
    elements.forEach(function(element) {
      var bounds = path.bounds(element);
      var dx = bounds[1][0] - bounds[0][0];
      var dy = bounds[1][1] - bounds[0][1];
      var x = (bounds[0][0] + bounds[1][0]) / 2;
      var y = (bounds[0][1] + bounds[1][1]) / 2;
      if ((Math.abs(x-viewport[0]) < (dx+(viewport[1]-viewport[0]))) && (Math.abs(y-viewport[2]) < (dy+(viewport[3]-viewport[2])))) {
        // console.log(JSON.stringify(bounds))
        ctx.beginPath();
        path(element);
        if (element == selectedElement) {
          ctx.fillStyle = "red";
        } else {ctx.fillStyle = "white";}
        ctx.fill()
        ctx.stroke();
        ctx.closePath();
      }
    })
   console.timeEnd("drawing");
  }

// // update the properties - It took more than 1 sec on my computer so I
// // rewrote it in python and I updated the topojson file prior to use. I
// // leave it there for information

// // sort the dataset by the geographic code
// dataset.sort(function(a, b) {return d3.ascending(a.properties.insee, b.properties.insee)})
// var j = 0;
// var arrondissements = {}
// // loop through the geometries
// for (var i = 0; i < dataset.length; i++) {
//   // get the INSEE id for this geometry
//   inseeId = dataset[i].properties.insee;
//   // if the INSEE id does not correspond to that of the row in the communes csv 
//   if (inseeId != dataLinks[i+j].insee) {
//     // if communes csv item is Marseille, Lyon or Paris
//     if (["Marseille", "Lyon", "Paris"].includes(dataLinks[i+j].nom)) {
//       // store the informations to use with arrondissements
//       arrondissements[dataLinks[i+j].nom] = dataLinks[i+j];
//       // increment counter to skip this csv row
//       j += 1;
//     // if the communes csv item is somewhere else process differences
//     } else {
//       // annotate in red
//       ctx.fillStyle = 'red';
//       // if the geometry is an arrondissement
//       if ((+inseeId > 13200 && +inseeId < 13217) || // Marseille
//           (+inseeId > 69380 && +inseeId < 69390) || // Lyon
//           (+inseeId > 75100 && +inseeId < 75121)) { // Paris
//         // decrement counter to keep current csv row
//         j -= 1;
//         // weird missing decrement after Paris arrondissements
//         if (+inseeId == 75120) {
//           j -= 1;
//         }
//       // if the geometry is not an arrondissement
//       } else {
//         // if the INSEE id is not present in geometries
//         if ([55138, 71578].includes(+dataLinks[i+j].insee)) {
//           // increment counter to skip this csv row
//           j += 1;
//         // if the INSEE id is not present in communes csv
//         } else if ([71138, 97501, 97502].includes(+inseeId)) {
//           // decrement counter to keep current csv row
//           j -= 1;
//         } else {
//           // there is a bug
//           console.log(i, dataset[i].properties)
//           console.log(dataLinks[i+j])
//           break;
//         }
//       }
//     }
//   // if the INSEE ids corresponds everything is fine
//   } else {
//     ctx.fillStyle = 'white';
//   }
//   // update the geometry properties with csv data
//   $.extend(true, dataset[i].properties, dataLinks[i+j])
//   // draw the current geometry with particular color
//   ctx.beginPath();
//   path(topojson.feature(map, dataset[i]));
//   ctx.fill();
//   ctx.stroke();
//   ctx.closePath();
// }

</script>

</body>
</html>